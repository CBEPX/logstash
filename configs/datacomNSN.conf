input {
  tcp {
    port => 5000
    type => syslog
  }
  udp {
    port => 5000
    type => mikrotik
  }
  udp {
    port => 5002
    type => fortinet
  }
  tcp {
    port   => 3515
    type   => eventlog
    codec  => json_lines
  }

}

filter {

 #  if  [@source] =~ /.*?(172.23.)/.*? {
 #        add_field => [ "@location", "31 Bullen St, Nelson" ]
 #  	 } # end of if	

  if [type] == "syslog" {

    grok {
      match => { "message" => "<%{POSINT:syslog_pri}>(?:%{SYSLOGTIMESTAMP:syslog_timestamp}|%{TIMESTAMP_ISO8601:syslog_timestamp8601}) %{SYSLOGHOST:syslog_hostname} %{PROG:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}" }
      add_field => [ "received@", "%{@timestamp}" ]
      add_field => [ "log_source", "%{syslog_hostname}" ]
      add_field => [ "customer", "DNZ-NSN" ]
    }  # end of grok

    syslog_pri { }

    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
#      match => [ "syslog_timestamp8601", "ISO8601"]   #RSYSLOG_ForwardFormat
    }   #end of date

    if !("_grokparsefailure" in [tags]) {
      mutate {
 #       replace => [ "@source_host", "%{syslog_hostname}" ]
        replace => [ "message", "%{syslog_message}" ]
      	     }  # end of mutate
    	   }  # end of if

    mutate {
      remove_field => [ "syslog_hostname", "syslog_message", "syslog_timestamp" ]
           }  # end of mutate

    }  # end of syslog IF

    if [type] == "eventlog" {

     # The EventReceivedTime field must contain only digits, or it is an invalid message
#    grep {
#        EventReceivedTime => "\d+"
#    	 }

    mutate {
        # Lowercase some values that are always in uppercase
        lowercase => [ "EventType", "FileName", "Hostname", "Severity", "Direction" ]
	add_field => [ "customer", "CATest" ]
    	   }

    mutate {
        # Set source to what the message says
        rename => [ "Hostname", "log_source" ]
    	   }

    date {
        # Convert timestamp from integer in UTC
        match => ["EventReceivedTime" , "UNIX"]
    	}

    mutate {
#        # Rename some fields into something more useful
      	add_field => [ "received@", "%{@timestamp}" ]
        rename => [ "Message", "message" ]
        rename => [ "Severity", "log_severity" ]
#        rename => [ "SeverityValue", "eventlog_severity_code" ]
        rename => [ "Channel", "win_channel" ]
        rename => [ "SourceName", "app_acting" ]
 #       rename => [ "SourceModuleName", "nxlog_input" ]
        rename => [ "Category", "win_category" ]
        rename => [ "EventID", "log_id" ]
        rename => [ "RecordNumber", "log_record" ]
        rename => [ "ProcessID", "app_pid" ]
        rename => [ "AccountType", "user_type" ]
        rename => [ "UserID", "user_id" ]
        rename => [ "AccountName", "user_name" ]
        rename => [ "Domain", "user_domain" ]
        rename => [ "TargetDomainName", "user_domain" ]
        rename => [ "TargetUserName", "user_name" ]
        rename => [ "SubjectDomainName", "user_domain" ]
        rename => [ "SubjectUserName", "user_name" ]
        rename => [ "TargetUserSid", "app_secid" ]
        rename => [ "DestPort", "dst_port" ]
        rename => [ "SourcePort", "src_port" ]
        rename => [ "DestAddress", "dst_ip" ]
        rename => [ "SourceAddress", "src_ip" ]
        rename => [ "Protocol", "ip_protocol" ]
        rename => [ "Application", "app_src" ]
	rename => [ "Direction" , "direction" ]
	rename => [ "ProcessName" , "app_src" ]
	rename => [ "CertificateDatabaseHash" , "app_CAcert_db_#" ]
	rename => [ "PrivateKeyUsageCount" , "app_CAcert_privkey_cnt" ]
	rename => [ "CACertificateHash" , "app_CAcert_#" ]
	rename => [ "CAPublicKeyHash" , "app_CAcert_pubkey_#" ]
	rename => [ "CACommonName", "app_src" ]
        rename => [ "AlgorithmName" , "app_CAcert_crypto" ]
   	 }

    if [win_category] == "Filtering Platform Packet Drop" {
        if  [direction] == "%%14592" {
       	  	      mutate { replace => ["direction", "in"] }
		      	     } # end of if
	if  [direction] == "%%14593" {
		         mutate { replace => ["direction", "out"] }
    		      	 } # end of if
	if "blocked" in [message] {
	                  mutate { add_field => ["action", "packets rejected"] }
			       } # end of if
	if "permitted" in [message] {
	                  mutate { add_field => ["action", "connection permitted"] }
			       } # end of if
   		
	} # end of if win_category

    if [win_category] == "Certification Services" or [win_channel] == "Application" {
       if "started" in [message] {
	                  mutate { add_field => ["action", "started"] }
			       } # end of if
       if "stopped" in [message] {
	                  mutate { add_field => ["action", "stopped"] }
			       } # end of if

	}


    mutate {
        # Remove redundant fields
        remove_field => [ "SourceModuleType", "EventTimeWritten", "EventTime", "EventReceivedTime", "EventType" ]
        remove_field => [ "SeverityValue", "SourceModuleName", "Keywords", "Task", "Opcode", "ThreadID", "ProviderGuid" ]
        remove_field => [ "Version", "OpcodeValue", "TargetLogonId", "LogonType", "TargetLogonGuid", "LogonGuid", "SubjectLogonId" ]
	remove_field => ["FilterRTID", "LayerRTID", "LayerName", "RemoteUserID", "RemoteMachineID", "ActivityID"]
	remove_field => ["OldSd", "NewSd",  "ObjectName", "ObjectType", "SubjectUserSid", "ResourceAttributes"]
	remove_field => [ "HandleId", "TransactionId", "AccessList", "AccessReason", "AccessMask"]
	remove_field => ["PrivilegeList", "RestrictedSidCount", "ResourceAttributes", "ObjectServer", "RoleSeparationEnabled"]
	remove_field => ["RelatedActivityID", "operationName", "SourceHandleId", "SourceProcessId", "TargetProcessId", "TargetHandleId"]
    	   }  # end of mutate

 }  # end of eventlog IF

  if [type] == "mikrotik" {
  
     grok {
     	   patterns_dir => ["/home/agasson/Dev/logstash/patterns/"]
     	   match => [ "message", "%{MTIKBSDSYSLOG}"  ]
      	   add_field => [ "received@", "%{@timestamp}" ]
	   add_field => [ "customer", "UNN" ]
      }

    syslog_pri { }

    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    }

    if !("_grokparsefailure" in [tags]) {
 
     mutate {
        replace => [ "message", "%{syslog_message}" ]
        remove_field => [ "syslog_pri" ]
      	    }

     grok  {
     	   patterns_dir => ["/home/agasson/Dev/logstash/patterns/"]
     	   match        => ["syslog_message", "%{MTIKWIFI}"  ]
           add_tag	 => "mikrotik grokked" 
      	   }

     }  # end of if grokparsefailure

  }  # end of mikrotik IF

  if [type] == "fortinet" {

     grok {
     	   match => [ "message", "^<%{POSINT:syslog_pri}>%{GREEDYDATA:msg_without_pri}" ]
       add_field => [ "received@", "%{@timestamp}" ]
       add_field => [ "log_source", "%{host}" ]
          }

  mutate {
  	 # Remove the priority field
  	 replace => ["message", "%{msg_without_pri}" ]
  	 remove_field =>  ["msg_without_pri"]
  	 }
    
  syslog_pri { }

 # get key values out for fortinet
    kv {
       add_field => { "device_timestamp" => "%{date} %{time}" }
    }

    date {
       match => [ "device_timestamp", "YYYY-MM-dd HH:mm:ss" ]
    }

   if !("_grokparsefailure" in [tags]) {
      mutate {
        replace => [ "log_source", "%{devname}" ]
      	}
     }

  if [msg] {
     	    mutate  {
     	    replace => [ "message", "%{msg}" ]
	    	    }
	   }

    mutate {
    	   remove_field => [ "log_id", "policyid", "device_id", "dst_country", "src_country", "date", "time" ]
    	   remove_field => [ "@source", "@source_path", "device_id", "devname" ]
	   remove_field => [ "syslog_pri", "pri", "type", "subtype", "proto" ]
    	   rename => [ "vd" , "customer" ]
    	   rename => [ "status" , "action" ]
    	   rename => [ "src" , "src_ip" ]
    	   rename => [ "dst" , "dst_ip" ]
    	   }

     }  # END of fortinet IF

    mutate {
      remove_field => [ "syslog_hostname", "syslog_message", "syslog_timestamp", "syslog_severity_code", "syslog_facility_code" ]
           }  # end of mutate

}   # END OF FILTER

output {
  # Example just to output to elasticsearch
   elasticsearch { 
	host => "172.23.248.30"
        protocol => http 
	}   # end of elasticsearch

  if [type] == "eventlog" or [type] == "mikrotik" {
    stdout { 
        codec => rubydebug 
	   }
     }
}
 #    graphite {
        # Ping the graphite server every time a syslog message is received
 #       type => "syslog"
 #       port => 2023     # carbon-aggregator
 #       metrics => [ "syslog.received.%{@source_host}.count", "1" ]
 #   }
 #   graphite {
        # Ping the graphite server every time an eventlog message is received
 #       type => "eventlog"
 #       port => 2023     # carbon-aggregator
 #       metrics => [ "eventlog.received.%{@source_host}.count", "1" ]
 #   }
